var W=Object.defineProperty;var Z=(c,t,e)=>t in c?W(c,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):c[t]=e;var w=(c,t,e)=>(Z(c,typeof t!="symbol"?t+"":t,e),e);import{bT as y,bN as I,G as g,bU as G,bV as B,bW as v,c0 as k,bX as p,bY as _,bZ as j,c_ as N,bw as S,b_ as D,cl as b,Z as A,z as T,aF as K,ck as M,gf as L,aM as H,bp as U,Y as z}from"./index-60943df8.js";import{o as C}from"./helpers-7076a817.js";var P=(c=>(c[c.GivenIn=0]="GivenIn",c[c.GivenOut=1]="GivenOut",c))(P||{});class J{constructor(t,e){w(this,"lastSwapRoute");this.pool=t,this.sdk=e}async exit(t){const e=await t.signer.getAddress();if(await this.queryExit(t),!this.lastSwapRoute)throw new Error("Could not fetch swap route for join.");const{to:s,data:o,value:i}=this.getSwapAttributes(t.exitType,this.lastSwapRoute,t.slippageBsp,e);return new y(t.signer).raw.sendTransaction({to:s,data:o,value:i})}async queryExit(t){return t.exitType===P.GivenIn?this.queryOutGivenIn(t):this.queryInGivenOut(t)}async queryOutGivenIn({bptIn:t,tokenInfo:e,amountsOut:s,signer:o}){const i=t,a=I(e,this.pool.value.address),n=e[s[0].address];if(!a||!n)throw new Error("Missing critical token metadata.");if(!i||g(i).eq(0))return{amountsOut:{[n.address]:"0"},priceImpact:0,txReady:!0};G.value||await B();const r=C(t,a.decimals),u=v(r,a.decimals),l=await this.getGasPrice(o);this.lastSwapRoute=await this.sdk.swaps.findRouteGivenIn({tokenIn:a.address,tokenOut:k(n.address),amount:u,gasPrice:l,maxPools:4});const d=p(this.lastSwapRoute.returnAmount,n.decimals);if(g(d).eq(0))throw new Error("Not enough liquidity.");const h=this.calcPriceImpact(i,d,this.lastSwapRoute.marketSp);return{amountsOut:{[n.address]:d},priceImpact:h,txReady:!0}}async queryInGivenOut({tokenInfo:t,amountsOut:e,signer:s}){const o=I(t,this.pool.value.address),i=I(t,e[0].address);if(!o||!i)throw new Error("Missing critical token metadata.");const a=e[0].value;if(!a||g(a).eq(0))return{amountsOut:{},priceImpact:0,txReady:!0};G.value||await B();const n=C(e[0].value,i.decimals),r=v(n,i.decimals),u=await this.getGasPrice(s);this.lastSwapRoute=await this.sdk.swaps.findRouteGivenOut({tokenIn:o.address,tokenOut:k(i.address),amount:r,gasPrice:u,maxPools:4});const l=p(this.lastSwapRoute.returnAmount,o.decimals);if(g(l).eq(0))throw new Error("Not enough liquidity.");const d=this.calcPriceImpact(l,a,this.lastSwapRoute.marketSp);return{amountsOut:{[i.address]:a},priceImpact:d,txReady:!0}}async getGasPrice(t){const e=(await t.getGasPrice()).toNumber();if(!e)throw new Error("Failed to fetch gas price.");return _.from(e)}calcPriceImpact(t,e,s){const i=g(t).div(e).div(s).minus(1)||1;return Math.max(0,i.toNumber())}getSwapAttributes(t,e,s,o){const i=j(60).toString(),a=t===P.GivenIn?N.SwapExactIn:N.SwapExactOut;return this.sdk.swaps.buildSwap({userAddress:o,swapInfo:e,kind:a,deadline:i,maxSlippage:s})}}class V{constructor(t,e){w(this,"exitTx");w(this,"exitInfo");this.pool=t,this.sdk=e}async exit(t){if(await this.queryExit(t),!this.exitTx)throw new Error("Could not query generalised exit");const e=new y(t.signer),{to:s,encodedCall:o}=this.exitTx;return e.raw.sendTransaction({to:s,data:o})}async queryExit({bptIn:t,signer:e,slippageBsp:s,relayerSignature:o,approvalActions:i,bptInValid:a}){var m,x,E,f;const n=v(t||"0",((m=this.pool.value.onchain)==null?void 0:m.decimals)??18);if(n.lte(0))throw new Error("BPT in amount is 0.");const r=await e.getAddress(),u=s.toString(),l=a&&i.length===0||!!o,d=S();try{this.exitInfo&&l?this.exitTx=await d.pools.generalisedExit(this.pool.value.id,n.toString(),r,u,e,D.Static,o,this.exitInfo.tokensToUnwrap):this.exitInfo=await d.pools.getExitInfo(this.pool.value.id,n.toString(),r,e)}catch(O){throw console.error(O),console.log("Failed here"),new Error("Failed to query exit.")}if(!this.exitInfo&&!this.exitTx)throw new Error("Failed to query exit.");return{priceImpact:g(p(((x=this.exitTx)==null?void 0:x.priceImpact)||this.exitInfo.priceImpact,18)).toNumber(),amountsOut:this.formatAmountsOut(((E=this.exitTx)==null?void 0:E.expectedAmountsOut)||this.exitInfo.estimatedAmountsOut,((f=this.exitTx)==null?void 0:f.tokensOut)||this.exitInfo.tokensOut),txReady:!!this.exitTx}}formatAmountsOut(t,e){const s={},o=b(this.pool.value);return t.forEach((i,a)=>{const n=o.find(r=>A(r.address,e[a]));if(n){const r=T(n.address),u=p(i,n.decimals??18).toString();s[r]=u}}),s}}class Y{constructor(t,e){w(this,"lastExitRes");this.pool=t,this.sdk=e}async exit(t){if(await this.queryExit(t),!this.lastExitRes)throw new Error("Failed to construct exit.");const e=new y(t.signer),{to:s,data:o}=this.lastExitRes;return e.raw.sendTransaction({to:s,data:o})}async queryExit(t){const{signer:e,tokenInfo:s,bptIn:o,slippageBsp:i,amountsOut:a}=t,n=await e.getAddress(),r=i.toString(),u=await S().pools.find(this.pool.value.id),l=I(s,a[0].address);if(!u)throw new Error("Failed to find pool: "+this.pool.value.id);if(!l)throw new Error("Could not find exit token in pool tokens list: "+a[0].address+" allTokens: "+JSON.stringify(Object.keys(s)));const d=a.length===1,h=v(o,18).toString(),m=k(l.address),x=d?m:void 0,E=A(l.address,K);if(this.lastExitRes=await u.buildExitExactBPTIn(n,h,r,E,x==null?void 0:x.toLowerCase()),!this.lastExitRes)throw new Error("Failed to construct exit.");const f=M(this.pool.value.address,this.lastExitRes.attributes.exitPoolRequest.assets),O=this.lastExitRes.expectedAmountsOut,R=await u.calcPriceImpact(O,h,!1),q=Number(p(R,18));if(d){const F=L(f,m);return{amountsOut:this.getSingleAmountOut(O,F,l),priceImpact:q,txReady:!0}}else return{amountsOut:this.getAmountsOut(O,f),priceImpact:q,txReady:!0}}getSingleAmountOut(t,e,s){const o=t[e],i=p(o,s.decimals).toString();return{[s.address]:i}}getAmountsOut(t,e){const s={},o=b(this.pool.value);return t.forEach((i,a)=>{const n=o.find(r=>A(r.address,e[a]));if(n){const r=T(n.address),u=p(i,n.decimals??18).toString();s[r]=u}}),s}}class X{constructor(t,e){w(this,"lastExitRes");this.pool=t,this.sdk=e}async exit(t){if(await this.queryExit(t),!this.lastExitRes)throw new Error("Failed to construct exit.");const e=new y(t.signer),{to:s,data:o}=this.lastExitRes;return e.raw.sendTransaction({to:s,data:o})}async queryExit(t){const{signer:e,tokenInfo:s,slippageBsp:o,amountsOut:i}=t,a=await e.getAddress(),n=o.toString(),r=await S().pools.find(this.pool.value.id),u=I(s,i[0].address);if(!r)throw new Error("Failed to find pool: "+this.pool.value.id);if(!u)throw new Error("Could not find exit token in pool tokens list: "+i[0].address+" allTokens: "+JSON.stringify(Object.keys(s)));const l=k(u.address),h=A(l,H.ZeroAddress)?this.replaceWethWithEth(this.pool.value.tokensList):U(this.pool.value),m=L(h,l),x=i[0].value,E=v(x,u.decimals).toString(),f=this.getFullAmounts(h,m,E);if(this.lastExitRes=r.buildExitExactTokensOut(a,h,f,n),!this.lastExitRes)throw new Error("Failed to construct exit.");const O=await r.calcPriceImpact(f,this.lastExitRes.expectedBPTIn,!1),R=Number(p(O,18));return{amountsOut:{[l]:x},priceImpact:R,txReady:!0}}replaceWethWithEth(t){return t.map(e=>A(e,z.Addresses.wNativeAsset)?H.ZeroAddress:e)}getFullAmounts(t,e,s){const o=t.map(()=>"0");return o[e]=s||"0",o}}class Q{constructor(t,e){w(this,"lastExitRes");this.pool=t,this.sdk=e}async exit(t){if(await this.queryExit(t),!this.lastExitRes)throw new Error("Failed to construct exit.");const e=new y(t.signer),{to:s,data:o}=this.lastExitRes;return e.raw.sendTransaction({to:s,data:o})}async queryExit(t){const{signer:e,bptIn:s,slippageBsp:o,toInternalBalance:i}=t,a=await e.getAddress(),n=o.toString(),r=await this.sdk.pools.find(this.pool.value.id);if(!r)throw new Error("Failed to find pool: "+this.pool.value.id);const u=await this.sdk.data.poolsOnChain.refresh(r),l=v(s,18).toString();if(this.lastExitRes=await this.sdk.pools.buildRecoveryExit({pool:u,userAddress:a,bptAmount:l,slippage:n,toInternalBalance:i}),!this.lastExitRes)throw new Error("Failed to construct exit.");const d=M(this.pool.value.address,this.lastExitRes.attributes.exitPoolRequest.assets),h=this.lastExitRes.expectedAmountsOut,m=await r.calcPriceImpact(h,l,!1),x=Number(p(m,18));return{amountsOut:this.getAmountsOut(h,d),priceImpact:x,txReady:!0}}getAmountsOut(t,e){const s={},o=b(this.pool.value);return t.forEach((i,a)=>{const n=o.find(r=>A(r.address,e[a]));if(n){const r=T(n.address),u=p(i,n.decimals??18).toString();s[r]=u}}),s}}var $=(c=>(c.Swap="Swap",c.Generalised="Generalised",c.ExactOut="ExactOut",c.ExactIn="ExactIn",c.Recovery="Recovery",c))($||{});class it{constructor(t,e=S()){w(this,"exitHandler");w(this,"exitHandlerMap");this.pool=t,this.sdk=e,this.exitHandlerMap={Swap:new J(t,e),Generalised:new V(t,e),ExactIn:new Y(t,e),ExactOut:new X(t,e),Recovery:new Q(t,e)},this.exitHandler=this.setExitHandler("Generalised")}setExitHandler(t){return this.exitHandler=this.exitHandlerMap[t]}async exit(t){return this.exitHandler.exit(t)}async queryExit(t){return this.exitHandler.queryExit(t)}}export{it as E,$ as a,P as b};
//# sourceMappingURL=exit-pool.service-ce4bf5d3.js.map
