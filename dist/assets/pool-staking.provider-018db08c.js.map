{"version":3,"file":"pool-staking.provider-018db08c.js","sources":["../../src/composables/queries/usePoolGaugesQuery.ts","../../src/providers/local/pool-staking.provider.ts"],"sourcesContent":["import { useQuery, UseQueryOptions } from '@tanstack/vue-query';\n\nimport QUERY_KEYS from '@/constants/queryKeys';\nimport { subgraphRequest } from '@/lib/utils/subgraph';\nimport { configService } from '@/services/config/config.service';\n\n/**\n * TYPES\n */\nexport type PoolGauges = {\n  __name: 'PoolGauges';\n  pool: {\n    preferentialGauge: {\n      id: string | null;\n    };\n    gauges: {\n      id: string;\n      relativeWeightCap: string;\n    }[];\n  };\n  liquidityGauges: { id: string }[];\n};\n\ntype QueryOptions = UseQueryOptions<PoolGauges>;\n\n/**\n * Fetches all gauges for a given pool and specifies which gauge is the\n * preferential gauge.\n */\nexport default function usePoolGaugesQuery(\n  poolAddress: Ref<string | undefined>,\n  options: UseQueryOptions<PoolGauges> = {}\n) {\n  /**\n   * QUERY KEY\n   */\n  const queryKey = reactive(QUERY_KEYS.Pool.Gauges(poolAddress));\n\n  /**\n   * COMPUTED\n   */\n  const enabled = computed((): boolean => !!poolAddress?.value);\n\n  const subgraphQuery = computed(() => ({\n    __name: 'PoolGauges',\n    pool: {\n      __args: {\n        id: poolAddress.value?.toLowerCase(),\n      },\n      preferentialGauge: {\n        id: true,\n      },\n      gauges: {\n        id: true,\n        relativeWeightCap: true,\n      },\n    },\n    liquidityGauges: {\n      __args: {\n        where: {\n          poolAddress: poolAddress.value?.toLowerCase(),\n        },\n      },\n      id: true,\n    },\n  }));\n\n  /**\n   * QUERY FUNCTION\n   */\n  const queryFn = async () => {\n    try {\n      return await subgraphRequest<PoolGauges>({\n        url: configService.network.subgraphs.gauge,\n        query: subgraphQuery.value,\n      });\n    } catch (error) {\n      console.error(\n        `Failed to fetch pool gauge for pool: ${poolAddress.value}`,\n        {\n          cause: error,\n        }\n      );\n      throw error;\n    }\n  };\n\n  /**\n   * QUERY OPTIONS\n   */\n  const queryOptions = reactive({\n    enabled,\n    refetchOnWindowFocus: false,\n    ...options,\n  });\n\n  return useQuery<PoolGauges>(queryKey, queryFn, queryOptions as QueryOptions);\n}\n","import usePoolGaugesQuery, {\n  PoolGauges,\n} from '@/composables/queries/usePoolGaugesQuery';\nimport { isQueryLoading } from '@/composables/queries/useQueryHelpers';\nimport symbolKeys from '@/constants/symbol.keys';\nimport { bnum, getAddressFromPoolId, isSameAddress } from '@/lib/utils';\nimport { computed, InjectionKey, provide } from 'vue';\nimport { LiquidityGauge } from '@/services/balancer/contracts/contracts/liquidity-gauge';\nimport { getAddress } from '@ethersproject/address';\nimport { parseUnits } from '@ethersproject/units';\nimport { useTokens } from '../tokens.provider';\nimport { TransactionResponse } from '@ethersproject/abstract-provider';\nimport useWeb3 from '@/services/web3/useWeb3';\nimport { POOLS } from '@/constants/pools';\nimport { safeInject } from '../inject';\nimport { useUserData } from '../user-data.provider';\nimport { subgraphRequest } from '@/lib/utils/subgraph';\nimport { configService } from '@/services/config/config.service';\n\n/**\n * PoolStakingProvider\n *\n * Fetches data and provides functionality for a specific pool's gauge.\n */\nexport const poolStakingProvider = (_poolId?: string) => {\n  /**\n   * STATE\n   */\n  const poolId = ref(_poolId);\n  const poolAddress = computed((): string | undefined =>\n    poolId.value ? getAddressFromPoolId(poolId.value) : undefined\n  );\n\n  /**\n   * COMPOSABLES\n   */\n  const { balanceFor } = useTokens();\n  const { account, isWalletReady } = useWeb3();\n\n  // Fetches all gauges for specified pool (incl. preferential gauge).\n  const poolGaugesQuery = usePoolGaugesQuery(poolAddress);\n  const { data: poolGauges, refetch: refetchPoolGauges } = poolGaugesQuery;\n\n  // Access user data fetched on wallet connection/change.\n  const { userGaugeSharesQuery, userBoostsQuery, stakedSharesQuery } =\n    useUserData();\n  const { data: userGaugeShares, refetch: refetchUserGaugeShares } =\n    userGaugeSharesQuery;\n  const { data: boostsMap, refetch: refetchUserBoosts } = userBoostsQuery;\n  const {\n    data: _stakedShares,\n    refetch: refetchStakedShares,\n    isRefetching: isRefetchingStakedShares,\n  } = stakedSharesQuery;\n\n  /**\n   * COMPUTED\n   */\n  const isLoading = computed(\n    (): boolean =>\n      isQueryLoading(poolGaugesQuery) ||\n      (isWalletReady.value &&\n        (isQueryLoading(stakedSharesQuery) ||\n          isQueryLoading(userGaugeSharesQuery) ||\n          isQueryLoading(userBoostsQuery)))\n  );\n\n  // The current preferential gauge for the specified pool.\n  const preferentialGaugeAddress = computed(\n    (): string | undefined | null =>\n      poolGauges.value?.pool?.preferentialGauge?.id\n  );\n\n  // Is it possible to stake this pool's BPT?\n  const isStakablePool = computed(\n    (): boolean =>\n      !!poolId.value &&\n      poolGauges.value?.liquidityGauges?.[0]?.id !== undefined &&\n      POOLS.Stakable.VotingGaugePools.concat(POOLS.Stakable.AllowList).includes(\n        poolId.value\n      )\n  );\n\n  // User's staked shares for pool (onchain data).\n  const stakedShares = computed((): string => {\n    if (!poolId.value) return '0';\n\n    return _stakedShares?.value?.[poolId.value] || '0';\n  });\n\n  // User's boost value for this pool\n  const boost = computed((): string => {\n    if (!boostsMap.value || !poolId.value) return '1';\n\n    return boostsMap[poolId.value] || '1';\n  });\n\n  // Addresses of all pool gauges.\n  const gaugeAddresses = computed(\n    (): string[] => poolGauges.value?.pool.gauges.map(gauge => gauge.id) || []\n  );\n\n  // Map of user gauge addresses -> balance.\n  const userGaugeSharesMap = computed((): Record<string, string> => {\n    if (!userGaugeShares.value) return {};\n\n    return userGaugeShares.value.reduce((acc, share) => {\n      acc[share.gauge.id] = share.balance;\n      return acc;\n    }, {} as Record<string, string>);\n  });\n\n  // Does the user have a balance in a non-preferential gauge\n  const hasNonPrefGaugeBalance = computed((): boolean => {\n    if (\n      !poolGauges.value ||\n      !userGaugeShares.value ||\n      !preferentialGaugeAddress.value\n    )\n      return false;\n\n    const _preferentialGaugeAddress = preferentialGaugeAddress.value;\n\n    return gaugeAddresses.value.some(\n      gaugeAddress =>\n        !isSameAddress(gaugeAddress, _preferentialGaugeAddress) &&\n        bnum(userGaugeSharesMap.value[gaugeAddress] || '0').gt(0)\n    );\n  });\n\n  /**\n   * METHODS\n   */\n\n  /**\n   * Set current pool ID for this provider.\n   *\n   * @param {string} id - The pool ID to get staking data for.\n   */\n  function setCurrentPool(id: string) {\n    poolId.value = id;\n  }\n\n  // Triggers refetch of all queries in this provider.\n  async function refetchAllPoolStakingData() {\n    return Promise.all([\n      refetchPoolGauges(),\n      refetchStakedShares(),\n      refetchUserGaugeShares(),\n      refetchUserBoosts(),\n    ]);\n  }\n\n  /**\n   * stake\n   *\n   * Trigger stake transaction using the current user's full BPT balance for\n   * this pool.\n   */\n  async function stake(): Promise<TransactionResponse> {\n    if (!poolAddress.value) throw new Error('No pool to stake.');\n    if (!preferentialGaugeAddress.value) {\n      throw new Error(\n        `No preferential gauge found for this pool: ${poolId.value}`\n      );\n    }\n\n    const gauge = new LiquidityGauge(preferentialGaugeAddress.value);\n    // User's current full BPT balance for this pool.\n    const userBptBalance = parseUnits(\n      balanceFor(getAddress(poolAddress.value))\n    );\n\n    return await gauge.stake(userBptBalance);\n  }\n\n  /**\n   * unstake\n   *\n   * Trigger unstake transaction using the first pool gauge that the user has a\n   * balance in.\n   */\n  async function unstake(): Promise<TransactionResponse> {\n    if (!poolGauges.value?.pool?.gauges)\n      throw new Error('Unable to unstake, no pool gauges');\n\n    const gaugesWithUserBalance = await filterGaugesWhereUserHasBalance(\n      poolGauges.value,\n      account.value\n    );\n    const firstGaugeWithUserBalance = gaugesWithUserBalance[0];\n    const gauge = new LiquidityGauge(firstGaugeWithUserBalance.id);\n    const balance = await gauge.balance(account.value);\n    return await gauge.unstake(balance);\n  }\n\n  /**\n   * Fetch preferential gauge address for pool.\n   *\n   * @param {string} poolAddress - The pool address to get gauge for.\n   * @returns {Promise<string>} - The preferential gauge address.\n   */\n  async function fetchPreferentialGaugeAddress(\n    poolAddress: string\n  ): Promise<string> {\n    try {\n      const data = await subgraphRequest<{\n        pool: { preferentialGauge: { id: string } };\n      }>({\n        url: configService.network.subgraphs.gauge,\n        query: {\n          pool: {\n            __args: {\n              id: poolAddress.toLowerCase(),\n            },\n            preferentialGauge: {\n              id: true,\n            },\n          },\n        },\n      });\n\n      return data.pool.preferentialGauge.id;\n    } catch (error) {\n      console.error(error);\n      throw error;\n    }\n  }\n\n  return {\n    isLoading,\n    stakedShares,\n    isStakablePool,\n    boost,\n    hasNonPrefGaugeBalance,\n    isRefetchingStakedShares,\n    refetchStakedShares,\n    preferentialGaugeAddress,\n    fetchPreferentialGaugeAddress,\n    setCurrentPool,\n    refetchAllPoolStakingData,\n    stake,\n    unstake,\n    poolGauges,\n  };\n};\n\n/**\n * Provide setup: response type + symbol.\n */\nexport type PoolStakingProviderResponse = ReturnType<\n  typeof poolStakingProvider\n>;\nexport const PoolStakingProviderSymbol: InjectionKey<PoolStakingProviderResponse> =\n  Symbol(symbolKeys.Providers.PoolStaking);\n\nexport function providePoolStaking(poolId?: string) {\n  provide(PoolStakingProviderSymbol, poolStakingProvider(poolId));\n}\n\nexport function usePoolStaking(): PoolStakingProviderResponse {\n  return safeInject(PoolStakingProviderSymbol);\n}\n\nasync function filterGaugesWhereUserHasBalance(\n  poolGauges: PoolGauges,\n  userAddress: string\n) {\n  // Insert user's balance in gauge objects\n  const gaugesWithBalance = await Promise.all(\n    poolGauges.pool.gauges.map(async gauge => {\n      const gaugeInstance = new LiquidityGauge(gauge.id);\n      const balance = await gaugeInstance.balance(userAddress);\n      return { ...gauge, balance: balance?.toString() };\n    })\n  );\n\n  const gaugesWhereUserHasBalance = gaugesWithBalance.filter(\n    gauge => gauge.balance !== '0'\n  );\n  if (gaugesWhereUserHasBalance.length === 0) {\n    throw new Error(`User doesn't have any balance for any gauges.`);\n  }\n  return gaugesWhereUserHasBalance;\n}\n"],"names":["usePoolGaugesQuery","poolAddress","options","queryKey","reactive","QUERY_KEYS","enabled","computed","subgraphQuery","_a","_b","queryFn","subgraphRequest","configService","error","queryOptions","useQuery","poolStakingProvider","_poolId","poolId","ref","getAddressFromPoolId","balanceFor","useTokens","account","isWalletReady","useWeb3","poolGaugesQuery","poolGauges","refetchPoolGauges","userGaugeSharesQuery","userBoostsQuery","stakedSharesQuery","useUserData","userGaugeShares","refetchUserGaugeShares","boostsMap","refetchUserBoosts","_stakedShares","refetchStakedShares","isRefetchingStakedShares","isLoading","isQueryLoading","preferentialGaugeAddress","_c","isStakablePool","POOLS","stakedShares","boost","gaugeAddresses","gauge","userGaugeSharesMap","acc","share","hasNonPrefGaugeBalance","_preferentialGaugeAddress","gaugeAddress","isSameAddress","bnum","setCurrentPool","id","refetchAllPoolStakingData","stake","LiquidityGauge","userBptBalance","parseUnits","getAddress","unstake","firstGaugeWithUserBalance","filterGaugesWhereUserHasBalance","balance","fetchPreferentialGaugeAddress","poolAddress2","PoolStakingProviderSymbol","symbolKeys","providePoolStaking","provide","usePoolStaking","safeInject","userAddress","gaugesWhereUserHasBalance"],"mappings":"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"}