{"version":3,"file":"useTokenApprovalActions-885c33f2.js","sources":["../../src/composables/approvals/types.ts","../../src/composables/approvals/useTokenApprovalActions.ts"],"sourcesContent":["export enum ApprovalAction {\n  AddLiquidity,\n  Locking,\n  Staking,\n  Swapping,\n  Unapprove,\n  Unwrapping,\n}\n","import { MaxUint256 } from '@ethersproject/constants';\nimport { useI18n } from 'vue-i18n';\nimport { useTokens } from '@/providers/tokens.provider';\nimport useWeb3 from '@/services/web3/useWeb3';\nimport { TransactionActionInfo } from '@/types/transactions';\nimport { ApprovalAction } from './types';\nimport { TransactionBuilder } from '@/services/web3/transactions/transaction.builder';\nimport { TokenInfo } from '@/types/TokenList';\nimport { parseUnits } from '@ethersproject/units';\nimport { TransactionResponse } from '@ethersproject/providers';\nimport useTransactions from '../useTransactions';\nimport { configService } from '@/services/config/config.service';\nimport { flatten } from 'lodash';\nimport { bnum } from '@/lib/utils';\n\n/**\n * TYPES\n */\nexport type AmountToApprove = {\n  address: string;\n  amount: string; // normalized amount\n};\n\ninterface Params {\n  amountsToApprove: AmountToApprove[];\n  spender: string;\n  actionType: ApprovalAction;\n  forceMax?: boolean;\n  skipAllowanceCheck?: boolean;\n}\n\ninterface ApproveTokenParams {\n  token: TokenInfo;\n  normalizedAmount: string;\n  spender: string;\n  actionType: ApprovalAction;\n  forceMax?: boolean;\n}\n\nexport default function useTokenApprovalActions() {\n  /**\n   * COMPOSABLES\n   */\n  const {\n    refetchAllowances,\n    approvalsRequired,\n    approvalRequired,\n    getToken,\n    injectSpenders,\n    allowanceFor,\n  } = useTokens();\n  const { t } = useI18n();\n  const { getSigner } = useWeb3();\n  const { addTransaction } = useTransactions();\n\n  /**\n   * METHODS\n   */\n  function actionLabel(actionType: ApprovalAction, symbol: string): string {\n    switch (actionType) {\n      case ApprovalAction.Locking:\n        return t('transactionSummary.approveForLocking', [symbol]);\n      case ApprovalAction.Staking:\n        return t('transactionSummary.approveForStaking', [symbol]);\n      case ApprovalAction.Swapping:\n        return t('transactionSummary.approveForSwapping', [symbol]);\n      case ApprovalAction.Unapprove:\n        return t('transactionSummary.unapprove', [symbol]);\n      case ApprovalAction.Unwrapping:\n        return t('transactionSummary.approveForUnwrapping', [symbol]);\n      default:\n        return t('transactionSummary.approveForInvesting', [symbol]);\n    }\n  }\n\n  function actionTooltip(actionType: ApprovalAction, symbol: string): string {\n    switch (actionType) {\n      case ApprovalAction.Locking:\n        return t('transactionSummary.tooltips.approveForLocking', [symbol]);\n      case ApprovalAction.Staking:\n        return t('transactionSummary.tooltips.approveForStaking', [symbol]);\n      case ApprovalAction.Swapping:\n        return t('transactionSummary.tooltips.approveForSwapping', [symbol]);\n      case ApprovalAction.Unapprove:\n        return t('transactionSummary.tooltips.unapprove', [symbol]);\n      case ApprovalAction.Unwrapping:\n        return t('transactionSummary.tooltips.approveForUnwrapping', [symbol]);\n      default:\n        return t('transactionSummary.tooltips.approveForInvesting', [symbol]);\n    }\n  }\n\n  async function updateAllowancesFor(spender: string): Promise<void> {\n    await injectSpenders([spender]);\n    await refetchAllowances();\n  }\n\n  async function getApprovalsRequired(\n    amountsToApprove: AmountToApprove[],\n    spender: string,\n    skipAllowanceCheck = false\n  ): Promise<AmountToApprove[]> {\n    if (!skipAllowanceCheck) {\n      await updateAllowancesFor(spender);\n    }\n\n    return approvalsRequired(amountsToApprove, spender);\n  }\n\n  async function isApprovalValid(\n    amountToApprove: AmountToApprove,\n    spender: string\n  ): Promise<boolean> {\n    if (bnum(amountToApprove.amount).eq(0)) return true;\n\n    await updateAllowancesFor(spender);\n\n    return !approvalRequired(\n      amountToApprove.address,\n      amountToApprove.amount,\n      spender\n    );\n  }\n\n  /**\n   * Triggers ERC20 approval transaction for a given token, waits for\n   * confirmation and then triggers the transaction notification.\n   *\n   * @param {TokenInfo} token The token to approve.\n   * @param {string} normalizedAmount The amount to approve, normalized, if\n   * forceMax is false.\n   * @param {string} spender The contract address to give the approval too,\n   * typically the vault.\n   * @param {ApprovalAction} actionType The action type that follows the\n   * approval, used for labeling of tx notification.\n   * @param {boolean} forceMax If true, the approval will be for the maximum\n   * possible amount.\n   * @returns {Promise<TransactionResponse>} The transaction response.\n   */\n  async function approveToken({\n    token,\n    normalizedAmount,\n    spender,\n    actionType,\n    forceMax = true,\n  }: ApproveTokenParams): Promise<TransactionResponse> {\n    const amount = forceMax\n      ? MaxUint256.toString()\n      : parseUnits(normalizedAmount, token.decimals).toString();\n\n    const txBuilder = new TransactionBuilder(getSigner());\n    const tx = await txBuilder.contract.sendTransaction({\n      contractAddress: token.address,\n      abi: [\n        'function approve(address spender, uint256 amount) public returns (bool)',\n      ],\n      action: 'approve',\n      params: [spender, amount],\n    });\n\n    addTransaction({\n      id: tx.hash,\n      type: 'tx',\n      action: 'approve',\n      summary: actionLabel(actionType, token.symbol),\n      details: {\n        contractAddress: token.address,\n        spender: spender,\n      },\n    });\n\n    return tx;\n  }\n\n  /**\n   * Some tokens require setting their approval amount to 0 first before being\n   * able to adjust the value up again. This returns true for tokens that requires\n   * this and false otherwise.\n   */\n  function isDoubleApprovalRequired(token, spender): boolean {\n    return !!(\n      configService.network.tokens.DoubleApprovalRequired?.includes(\n        token.address\n      ) && allowanceFor(token.address, spender).gt(0)\n    );\n  }\n\n  /**\n   * Create an action for BalActionSteps that approves a token for spending.\n   * @param {TokenInfo} token The token to approve.\n   * @param {string} normalizedAmount The amount to approve, normalized, if\n   * forceMax is false.\n   * @param {string} spender The contract address to give the approval too,\n   * typically the vault.\n   * @param {ApprovalAction} actionType The action type that follows the\n   * approval, used for labeling of tx notification.\n   * @param {boolean} forceMax If true, the approval will be for the maximum\n   * possible amount.\n   * @returns {TransactionActionInfo} The transaction\n   */\n  function createApprovalAction({\n    token,\n    normalizedAmount,\n    spender,\n    actionType,\n    forceMax = true,\n  }: ApproveTokenParams): TransactionActionInfo {\n    return {\n      label: actionLabel(actionType, token.symbol),\n      loadingLabel: t('investment.preview.loadingLabel.approval'),\n      confirmingLabel: t('confirming'),\n      stepTooltip: actionTooltip(actionType, token.symbol),\n      action: () => {\n        return approveToken({\n          token,\n          normalizedAmount,\n          spender,\n          actionType,\n          forceMax,\n        });\n      },\n      postActionValidation: () => {\n        return isApprovalValid(\n          { address: token.address, amount: normalizedAmount },\n          spender\n        );\n      },\n      actionInvalidReason: {\n        title: t('actionSteps.approve.invalidReason.title'),\n        description: t('actionSteps.approve.invalidReason.description'),\n      },\n    };\n  }\n\n  /**\n   * Returns a list of TransactionActions to approve tokens for a given spender.\n   * Typically used to inject into BalActionSteps.\n   *\n   * @param {AmountToApprove[]} amountsToApprove The list of tokens and amounts\n   * to approve.\n   * @param {string} spender The contract address to give the approval too,\n   * typically the vault.\n   * @param {ApprovalAction} actionType The action type that follows the\n   * approval, used for labeling.\n   * @param {boolean} forceMaxApprovals If true, the approval will be for the\n   * maximum possible amount.\n   * @returns {Promise<TransactionActionInfo[]>} The list of TransactionActions.\n   */\n  async function getTokenApprovalActions({\n    amountsToApprove,\n    spender,\n    actionType,\n    forceMax = true,\n    skipAllowanceCheck = false,\n  }: Params): Promise<TransactionActionInfo[]> {\n    const approvalsRequired = await getApprovalsRequired(\n      amountsToApprove,\n      spender,\n      skipAllowanceCheck\n    );\n\n    return flatten(\n      approvalsRequired.map(amountToApprove => {\n        const token = getToken(amountToApprove.address);\n        const actions: TransactionActionInfo[] = [];\n\n        /**\n         * Some tokens require setting approved amount to 0 before changing the\n         * approval amount. This injects another action to do that.\n         */\n        if (isDoubleApprovalRequired(token, spender)) {\n          actions.push(\n            createApprovalAction({\n              token,\n              normalizedAmount: '0',\n              spender,\n              actionType: ApprovalAction.Unapprove,\n              forceMax: false,\n            })\n          );\n        }\n\n        actions.push(\n          createApprovalAction({\n            token,\n            normalizedAmount: amountToApprove.amount,\n            spender,\n            actionType,\n            forceMax,\n          })\n        );\n\n        return actions;\n      })\n    );\n  }\n\n  return {\n    approveToken,\n    getTokenApprovalActions,\n    updateAllowancesFor,\n  };\n}\n"],"names":["ApprovalAction","ApprovalAction2","useTokenApprovalActions","refetchAllowances","approvalsRequired","approvalRequired","getToken","injectSpenders","allowanceFor","useTokens","t","useI18n","getSigner","useWeb3","addTransaction","useTransactions","actionLabel","actionType","symbol","actionTooltip","updateAllowancesFor","spender","getApprovalsRequired","amountsToApprove","skipAllowanceCheck","isApprovalValid","amountToApprove","bnum","approveToken","token","normalizedAmount","forceMax","amount","MaxUint256","parseUnits","tx","TransactionBuilder","isDoubleApprovalRequired","_a","configService","createApprovalAction","getTokenApprovalActions","flatten","actions"],"mappings":"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"}