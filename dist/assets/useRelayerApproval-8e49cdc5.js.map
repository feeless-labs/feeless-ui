{"version":3,"file":"useRelayerApproval-8e49cdc5.js","sources":["../../src/composables/queries/useRelayerApprovalQuery.ts","../../src/composables/approvals/useRelayerApprovalTx.ts","../../src/services/web3/wallet-names.ts","../../src/dependencies/Relayer.ts","../../src/composables/approvals/useRelayerApproval.ts"],"sourcesContent":["import { Vault__factory } from '@balancer-labs/typechain';\nimport { getEthersContract } from '@/dependencies/EthersContract';\nimport { computed, reactive, Ref } from 'vue';\nimport { useQuery, UseQueryOptions } from '@tanstack/vue-query';\n\nimport QUERY_KEYS from '@/constants/queryKeys';\nimport { FETCH_ONCE_OPTIONS } from '@/constants/vue-query';\nimport { configService } from '@/services/config/config.service';\nimport { rpcProviderService } from '@/services/rpc-provider/rpc-provider.service';\nimport useWeb3 from '@/services/web3/useWeb3';\n\nimport useNetwork from '../useNetwork';\n\n/**\n * TYPES\n */\ntype QueryResponse = boolean;\ntype QueryOptions = UseQueryOptions<QueryResponse>;\n\nexport default function useRelayerApprovalQuery(\n  relayer: Ref<string>,\n  options: QueryOptions = {}\n) {\n  /**\n   * COMPOSABLES\n   */\n  const { account, isWalletReady } = useWeb3();\n  const { networkId } = useNetwork();\n\n  /**\n   * COMPUTED\n   */\n  const enabled = computed(() => isWalletReady.value);\n\n  const EthersContract = getEthersContract();\n  const vaultContract = computed(\n    () =>\n      new EthersContract(\n        configService.network.addresses.vault,\n        Vault__factory.abi,\n        rpcProviderService.jsonProvider\n      )\n  );\n\n  /**\n   * QUERY INPUTS\n   */\n  const queryKey = reactive(\n    QUERY_KEYS.Account.RelayerApprovals(networkId, account, relayer)\n  );\n\n  const queryFn = async (): Promise<boolean> => {\n    if (!relayer.value) {\n      return true;\n    }\n\n    const approved = await vaultContract.value.hasApprovedRelayer(\n      account.value,\n      relayer.value\n    );\n\n    return approved;\n  };\n\n  const queryOptions = reactive({\n    enabled,\n    ...FETCH_ONCE_OPTIONS,\n    ...options,\n  });\n\n  return useQuery<QueryResponse>(\n    queryKey,\n    queryFn,\n    queryOptions as QueryOptions\n  );\n}\n","import { Vault__factory } from '@balancer-labs/typechain';\nimport { TransactionResponse } from '@ethersproject/abstract-provider';\nimport { computed, Ref, ref } from 'vue';\nimport { useI18n } from 'vue-i18n';\n\nimport { configService } from '@/services/config/config.service';\nimport useWeb3 from '@/services/web3/useWeb3';\nimport { TransactionActionInfo } from '@/types/transactions';\n\nimport useRelayerApprovalQuery from '../queries/useRelayerApprovalQuery';\nimport useEthers from '../useEthers';\nimport useTransactions from '../useTransactions';\nimport { TransactionBuilder } from '@/services/web3/transactions/transaction.builder';\nimport { relayerAddressMap, RelayerType } from './useRelayerApproval';\n\nconst vaultAddress = configService.network.addresses.vault;\n\nexport default function useRelayerApprovalTx(\n  relayer: RelayerType,\n  isEnabled: Ref<boolean> = ref(true)\n) {\n  /**\n   * STATE\n   */\n  const init = ref(false);\n  const approving = ref(false);\n  const approved = ref(false);\n\n  /**\n   * COMPOSABLES\n   */\n  const { getSigner, account } = useWeb3();\n  const relayerAddress = ref(relayerAddressMap[relayer]);\n  const { txListener } = useEthers();\n  const { addTransaction } = useTransactions();\n  const { t } = useI18n();\n  const relayerApproval = useRelayerApprovalQuery(relayerAddress);\n\n  /**\n   * COMPUTED\n   */\n  const isUnlocked = computed(\n    () =>\n      approved.value || (isEnabled.value ? !!relayerApproval.data.value : true)\n  );\n\n  const loading = computed(\n    (): boolean =>\n      relayerApproval.isLoading.value || relayerApproval.isError.value\n  );\n\n  const action = computed(\n    (): TransactionActionInfo => ({\n      label: t('transactionSummary.approveRelayer', [relayer]),\n      loadingLabel: t('actionSteps.approve.loadingLabel'),\n      confirmingLabel: t('confirming'),\n      stepTooltip: t('approveRelayerTooltip'),\n      action: approve,\n    })\n  );\n\n  /**\n   * METHODS\n   */\n  async function approve(): Promise<TransactionResponse> {\n    try {\n      init.value = true;\n\n      const txBuilder = new TransactionBuilder(getSigner());\n      const tx = await txBuilder.contract.sendTransaction({\n        contractAddress: configService.network.addresses.vault,\n        abi: Vault__factory.abi,\n        action: 'setRelayerApproval',\n        params: [account.value, relayerAddress.value, true],\n      });\n\n      init.value = false;\n      approving.value = true;\n\n      handleTransaction(tx);\n      return tx;\n    } catch (e) {\n      console.log(e);\n      init.value = false;\n      approving.value = false;\n      return Promise.reject(e);\n    }\n  }\n\n  async function handleTransaction(tx): Promise<void> {\n    addTransaction({\n      id: tx.hash,\n      type: 'tx',\n      action: 'approve',\n      summary: t('transactionSummary.approveRelayer', [relayer]),\n      details: {\n        contractAddress: vaultAddress,\n        spender: relayerAddress.value,\n      },\n    });\n\n    approved.value = await txListener(tx, {\n      onTxConfirmed: async () => {\n        approving.value = false;\n        relayerApproval.refetch();\n      },\n      onTxFailed: () => {\n        approving.value = false;\n      },\n    });\n  }\n\n  return {\n    action,\n    init,\n    approve,\n    approving,\n    approved,\n    isUnlocked,\n    loading,\n  };\n}\n","import { useI18n } from 'vue-i18n';\nimport { ConnectorId } from './connectors/connector';\n\nexport function getConnectorName(\n  connectorId: ConnectorId,\n  provider: any\n): string {\n  const { t } = useI18n();\n\n  if (!provider) {\n    return t('unknown');\n  }\n  if (connectorId === ConnectorId.InjectedMetaMask) {\n    if (provider.isCoinbaseWallet) {\n      return `Coinbase ${t('wallet')}`;\n    }\n    if (provider.isMetaMask) {\n      return 'MetaMask';\n    }\n    if (provider.isImToken) {\n      return 'imToken';\n    }\n    if (provider.isStatus) {\n      return 'Status';\n    }\n    if (provider.isTrust) {\n      return 'Trust Wallet';\n    }\n    if (provider.isFrame) {\n      return 'Frame';\n    }\n    return t('browserWallet');\n  }\n  if (connectorId === ConnectorId.InjectedTally) {\n    return 'Tally';\n  }\n  if (connectorId === ConnectorId.WalletConnect) {\n    return 'WalletConnect';\n  }\n  if (connectorId === ConnectorId.WalletLink) {\n    return `Coinbase ${t('wallet')}`;\n  }\n  if (connectorId === ConnectorId.Gnosis) {\n    return 'Gnosis Safe';\n  }\n  return t('unknown');\n}\n\nexport function isWalletConnectWallet(connectorId: ConnectorId) {\n  return connectorId === ConnectorId.WalletConnect;\n}\n","import { Relayer } from '@feeless/sdk';\nimport { handleDependencyError } from '.';\n\nlet _Relayer: typeof Relayer = Relayer;\n\n/**\n * Uses the real Relayer instance by default but allows injecting Relayer mocks from tests\n */\nexport function initRelayer(RelayerInstance: typeof Relayer = Relayer) {\n  _Relayer = RelayerInstance;\n}\n\nexport function getRelayer() {\n  if (!_Relayer) {\n    handleDependencyError('Relayer');\n  }\n  return _Relayer;\n}\n","import useWeb3 from '@/services/web3/useWeb3';\nimport { computed, ref, watch } from 'vue';\nimport useNetwork from '../useNetwork';\nimport { Vault } from '@feeless/sdk';\nimport { configService } from '@/services/config/config.service';\nimport { Vault__factory } from '@balancer-labs/typechain';\nimport { useI18n } from 'vue-i18n';\nimport { TransactionActionInfo } from '@/types/transactions';\nimport useRelayerApprovalTx from '@/composables/approvals/useRelayerApprovalTx';\nimport useGnosisSafeApp from '@/composables/useGnosisSafeApp';\nimport { COW_RELAYER_CONTRACT_ADDRESS } from '@/services/cowswap_deprecated/constants';\nimport { isWalletConnectWallet } from '@/services/web3/wallet-names';\nimport { useUserSettings } from '@/providers/user-settings.provider';\nimport { getRelayer } from '@/dependencies/Relayer';\n\n/**\n * TYPES\n */\nexport enum RelayerType {\n  COWSWAP = 'Cowswap',\n  LIDO = 'Lido',\n  BATCH = 'Batch',\n}\n\nexport const relayerAddressMap = {\n  [RelayerType.COWSWAP]: COW_RELAYER_CONTRACT_ADDRESS,\n  [RelayerType.LIDO]: configService.network.addresses.lidoRelayer,\n  [RelayerType.BATCH]: configService.network.addresses.batchRelayer,\n};\n\n/**\n * STATE\n */\nconst relayerSignature = ref<string>('');\n\nexport default function useRelayerApproval(relayerType: RelayerType) {\n  /**\n   * COMPOSABLES\n   */\n  const { account, getSigner, connector } = useWeb3();\n  const { networkId } = useNetwork();\n  const { t } = useI18n();\n  const { isGnosisSafeApp } = useGnosisSafeApp();\n  const relayerApprovalTx = useRelayerApprovalTx(relayerType);\n  const { supportSignatures } = useUserSettings();\n\n  const signatureAction: TransactionActionInfo = {\n    label: t('signRelayerApproval'),\n    loadingLabel: t('checkWallet'),\n    confirmingLabel: t('signingRelayerApproval'),\n    stepTooltip: t('signRelayerApprovalTooltip'),\n    action: signRelayerApproval as () => Promise<any>,\n    isSignAction: true,\n  };\n\n  /**\n   * COMPUTED\n   */\n\n  const relayerApprovalAction = computed((): TransactionActionInfo => {\n    return !supportSignatures.value ||\n      isGnosisSafeApp.value ||\n      isWalletConnectWallet(connector.value?.id)\n      ? relayerApprovalTx.action.value\n      : signatureAction;\n  });\n\n  /**\n   * METHODS\n   */\n  async function signRelayerApproval(): Promise<void> {\n    const Relayer = getRelayer();\n    const relayerAddress = relayerAddressMap[relayerType];\n    const signer = getSigner();\n    const signerAddress = await signer.getAddress();\n    const signature = await Relayer.signRelayerApproval(\n      relayerAddress,\n      signerAddress,\n      signer,\n      Vault__factory.connect(\n        configService.network.addresses.vault,\n        signer\n      ) as unknown as Vault\n    );\n    relayerSignature.value = signature;\n  }\n\n  /**\n   * WATCHERS\n   */\n  watch([account, networkId], () => {\n    relayerSignature.value = '';\n  });\n\n  return {\n    relayerSignature,\n    relayerApprovalAction,\n    relayerApprovalTx,\n  };\n}\n"],"names":["useRelayerApprovalQuery","relayer","options","account","isWalletReady","useWeb3","networkId","useNetwork","enabled","computed","EthersContract","getEthersContract","vaultContract","configService","Vault__factory","rpcProviderService","queryKey","reactive","QUERY_KEYS","queryFn","queryOptions","FETCH_ONCE_OPTIONS","useQuery","vaultAddress","useRelayerApprovalTx","isEnabled","ref","init","approving","approved","getSigner","relayerAddress","relayerAddressMap","txListener","useEthers","addTransaction","useTransactions","t","useI18n","relayerApproval","isUnlocked","loading","action","approve","tx","TransactionBuilder","handleTransaction","e","isWalletConnectWallet","connectorId","ConnectorId","_Relayer","Relayer","getRelayer","handleDependencyError","RelayerType","COW_RELAYER_CONTRACT_ADDRESS","relayerSignature","useRelayerApproval","relayerType","connector","isGnosisSafeApp","useGnosisSafeApp","relayerApprovalTx","supportSignatures","useUserSettings","signatureAction","signRelayerApproval","relayerApprovalAction","_a","signer","signerAddress","signature","watch"],"mappings":"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"}