{"version":3,"file":"user-tokens.provider-a558a35f.js","sources":["../../src/providers/local/user-tokens.provider.ts"],"sourcesContent":["import symbolKeys from '@/constants/symbol.keys';\nimport { bnum, includesAddress } from '@/lib/utils';\nimport { safeInject } from '../inject';\nimport { useTokens } from '../tokens.provider';\n\n/**\n * Provides access to functionality related to tokens in a user's connected\n * wallet.\n */\nexport function userTokensProvider() {\n  /**\n   * COMPOSABLES\n   */\n  const {\n    balances,\n    balanceFor,\n    balanceQueryLoading: isLoadingBalances,\n  } = useTokens();\n\n  /**\n   * COMPUTED\n   */\n  // Array of token addresses that have a balance in the user's wallet.\n  const tokensWithBalance = computed<string[]>(() => {\n    return Object.keys(balances.value).filter(tokenAddress => {\n      return bnum(balanceFor(tokenAddress)).gt(0);\n    });\n  });\n\n  /**\n   * METHODS\n   */\n\n  /**\n   * Get subset of tokensWithBalance included in the provided array of addresses.\n   *\n   * @param {string[]} addresses Array of token addresses to filter by.\n   * @returns Array of token addresses that are included in the provided array of addresses.\n   */\n  function tokensWithBalanceFrom(addresses: string[]): string[] {\n    return addresses.filter(address =>\n      includesAddress(tokensWithBalance.value, address)\n    );\n  }\n\n  /**\n   * Get subset of tokensWithBalance not included in the provided array of addresses.\n   *\n   * @param {string[]} addresses Array of token addresses to filter by.\n   * @returns Array of token addresses that are not included in the provided array of addresses.\n   */\n  function tokensWithBalanceNotIn(addresses: string[]): string[] {\n    return tokensWithBalance.value.filter(\n      address => !includesAddress(addresses, address)\n    );\n  }\n\n  /**\n   * Get subset of provided addresses not included in the tokensWithBalance array.\n   *\n   * @param {string[]} addresses Array of token addresses to filter by.\n   * @returns Array of token addresses without a balance in the user's wallet.\n   */\n  function tokensWithoutBalanceFrom(addresses: string[]): string[] {\n    return addresses.filter(\n      address => !includesAddress(tokensWithBalance.value, address)\n    );\n  }\n\n  return {\n    isLoadingBalances,\n    tokensWithBalance,\n    tokensWithBalanceFrom,\n    tokensWithoutBalanceFrom,\n    tokensWithBalanceNotIn,\n  };\n}\n\n/**\n * Provider setup: response type + symbol.\n */\nexport type UserTokensProviderResponse = ReturnType<typeof userTokensProvider>;\nexport const UserTokensProviderSymbol: InjectionKey<UserTokensProviderResponse> =\n  Symbol(symbolKeys.Providers.UserTokens);\n\nexport function provideUserTokens(): UserTokensProviderResponse {\n  const _provider = userTokensProvider();\n  provide(UserTokensProviderSymbol, _provider);\n  return _provider;\n}\n\nexport function useUserTokens(): UserTokensProviderResponse {\n  return safeInject(UserTokensProviderSymbol);\n}\n"],"names":["userTokensProvider","balances","balanceFor","isLoadingBalances","useTokens","tokensWithBalance","computed","tokenAddress","bnum","tokensWithBalanceFrom","addresses","address","includesAddress","tokensWithBalanceNotIn","tokensWithoutBalanceFrom","UserTokensProviderSymbol","symbolKeys","provideUserTokens","_provider","provide","useUserTokens","safeInject"],"mappings":"sFASO,SAAAA,GAAA,CAIL,KAAA,CAAM,SAAAC,EACJ,WAAAC,EACA,oBAAAC,CACqB,EAAAC,EAAA,EAOvBC,EAAAC,EAAA,IACE,OAAA,KAAAL,EAAA,KAAA,EAAA,OAAAM,GACEC,EAAAN,EAAAK,CAAA,CAAA,EAAA,GAAA,CAAA,CAA0C,CAC3C,EAaH,SAAAE,EAAAC,EAAA,CACE,OAAAA,EAAA,OAAiBC,GAAAC,EAAAP,EAAA,MAAAM,CAAA,CACiC,CAClD,CASF,SAAAE,EAAAH,EAAA,CACE,OAAAL,EAAA,MAAA,OAA+BM,GAAA,CAAAC,EAAAF,EAAAC,CAAA,CACiB,CAChD,CASF,SAAAG,EAAAJ,EAAA,CACE,OAAAA,EAAA,OAAiBC,GAAA,CAAAC,EAAAP,EAAA,MAAAM,CAAA,CAC6C,CAC9D,CAGF,MAAA,CAAO,kBAAAR,EACL,kBAAAE,EACA,sBAAAI,EACA,yBAAAK,EACA,uBAAAD,CACA,CAEJ,CAMO,MAAAE,EAAA,OAAAC,EAAA,UAAA,UAAA,EAGA,SAAAC,GAAA,CACL,MAAAC,EAAAlB,IACA,OAAAmB,EAAAJ,EAAAG,CAAA,EACAA,CACF,CAEO,SAAAE,GAAA,CACL,OAAAC,EAAAN,CAAA,CACF"}